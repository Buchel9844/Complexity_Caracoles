---
title: "Natural_data"
author: "Lisa Buche"
date: "04/08/2022"
output:
  html_document:
    number_sections: yes
    theme: lumen
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

# Results 

After proving the validity of the Bayesian frameworks woth the addition of HOIs and the sparsity approach (Annexe "Simulation verification")

Try simulation with real data. Thedata-set used has been collected in Caracoles Ranch (2680 ha), an annual grassland system located in Doñana NP, southwest Spain (37°04001.5″ N6°19016.2″ W). More details about the collection and protocols follow can be found in the Methods of Chapter 1. 

# Creation of a dataset


```{r Import packages, include=FALSE}
#First, set the working directory and import the relevant packages. The set working directory is defined by the location of this file. You can overwrite it, yet this is not advised. The packages imported are: "rstan", "HDInterval","tidyverse","dplyr","ggpubr", and "ggplot2". If any of them have not been installed previously, please uncomment the 'install.packages' command below. 
 
#setwd("~/Code/Project/Facilitation_density/code/Simul_Data/") # set working directory

#install.packages("rstan", repos = "https://cloud.r-project.org/",dependencies = TRUE)
library(rstan)
#install.packages("HDInterval")
library("HDInterval")
#install.packages("tidyverse")
library("tidyverse")
#install.packages("dplyr")
library(dplyr)
library(ggpubr)
library(ggplot2)
library(ggthemes)
#install.packages("MASS") # important to update the latest version. Attention, it overwrites some of dplyr functions. 
library(MASS)  # the glm.neg model requires this packagefor the fits to be performed and/or to converge	
library("knitr")
#library("knitr", lib.loc="/Library/Frameworks/R.framework/Versions/4.0/Resources/library")
library(readr)
```

Import the data-set.
```{r import data-set, echo=FALSE}
rm(list = ls())
#---- Import the Data ----
# if on local comp, add /Users/lisabuche/Code/Project/Caracoles/data/

abundance.plant <- read.csv("~/Eco_Bayesian/data/abundance.csv")

competition.plant <- read.csv("data/competition.csv", sep=",")

plant.class <- read.csv("data/plant_code.csv", sep=",")

```

Set parameters. 
 
```{r set parameters, echo=TRUE}
#---- Set parameters ----

summary.interactions <- data.frame()
years <- "2020"
focal <- "CHFU"
complexity.plant  <- "class"
complexity.animal  <- "class"
```

Create dataframe to use for model fit.
First we subset the data-set for our focal species and the complexity level of interest for both the plants and the floral visitors/herbivores. 

```{r create dataframe for focal, echo=FALSE}

#for ( years in c("2016","2017",'2018',,"2019","2020","2021")){
#  for ( focal in c("CHFU","LEMA",'HOMA',"CETE")){
#  }
#}

#---- setting ups----    
# view complexity levels 
summary.interactions.n <- data.frame()
print(focal)
print(complexity.plant)
# determine the levels of complexity for plant 
complexitylevel.plant <- levels(as.factor(plant.class[,complexity.plant]))

if (complexity.plant != "code.plant"){complexity.minimize <- T}else{complexity.minimize <- F}

FocalPrefix <- focal # "LEMA" or "HOMA" or "CHFU"

# Load in the data and subset out the current focal species and complexity levels
#SpData <- read.csv("/home/lisavm/Simulations/data/competition.csv")
SpData <- read.csv("data/SpData.csv")

SpData <- na.omit(SpData) 
#SpData <- subset(SpData, year == years)
str(SpData)
SpData<- dplyr::select(SpData,all_of(c("day","month", "year","plot","subplot" ,"focal",
                                "fruit","seed",complexitylevel.plant,FocalPrefix)))

SpDataFocal <- SpData[which(SpData$focal == FocalPrefix & SpData$year==years),]
#head(SpDataFocal)


if (complexity.minimize == T){
  levels.of.focal <- plant.class[which(plant.class$code.plant==FocalPrefix),complexity.plant]
  SpDataFocal[,levels.of.focal] <- SpDataFocal[,levels.of.focal] - SpDataFocal[,FocalPrefix]
}

head(SpDataFocal)

```

Then we need to create the abundance dataframes that are fit in the model. These dataframes are matrix of abundance, with the columns corresponding to the neighboorhood considered. 

```{r create dataframes, echo=FALSE}
# Next continue to extract the data needed to run the model. 
N <- as.integer(nrow(SpDataFocal))
Fecundity <- as.integer(SpDataFocal$seed)  
#plot <- as.integer(factor(as.factor(SpDataFocal$plot), levels = c("1","2","3","4","5","6","7","8","9")))

#---- Interaction (direct) matrix of plant with COMP ----

# Now calculate the total number of plant species to use for the model, discounting
#       any species columns with 0 abundance. Save a vector of the species names
#       corresponding to each column for easy matching later.
AllSpNames <- names(SpDataFocal)[!names(SpDataFocal) %in% c("day","month","year","plot",
                                                            "subplot", "focal","fruit","seed","fitness")]
 
AllSpAbunds <- SpDataFocal %>% 
  dplyr::select(all_of(AllSpNames))

SpTotals <- colSums(AllSpAbunds)
SpToKeep <- SpTotals > 0

S <- sum(SpToKeep)
SpMatrix <- matrix(NA, nrow = N, ncol = S)
i <- 1
for(s in 1:ncol(AllSpAbunds)){
  if(SpToKeep[s] == 1){
    SpMatrix[,i] <- AllSpAbunds[,s]
    i <- i + 1
  }else{next}
}
SpMatrix <-round((SpMatrix/max(SpMatrix))*100) #scale all the interaction between 0 and 100
if(max(SpMatrix) == 100){print("scale SpMatrix_plant correct")}

SpNames <- AllSpNames[SpToKeep]

#assign(paste0("SpNames_",FocalPrefix),
#     SpNames)
Intra <- ifelse(SpNames == "intra", 1, 0)

# creation of a matrix of S by S of the interaction jk in HOIs_ijk for plants
matrix_HOIs_plant <- list()
for (i in 1:N){
  matrix_i <- matrix(nrow=S,ncol=S)
  for (n in 1:S) {
    for (m in 1:S) {
      if (m <= n){
        matrix_i[n,m] = 0
      }
      else{
        matrix_i[n,m] = SpMatrix[i,n]* SpMatrix[i,m]
      } 
    }
  }
  matrix_i[is.na(matrix_i)] <- 0
  matrix_HOIs_plant[[i]] <-  matrix_i
}

```

#  Preliminary fit

We fit a preliminaryt model according to the sparsity approach constructed by Dr. Christopher Weiss-Lehman.  The Sparsity approach identifies the relevant interactions in a prior fit which focuses on the distributions of the coefficients around 0. Once the relevant interactions are identified, a final fit is performed to estimate the coefficient distribution confidently. The conjugation of a Bayes approach with a Sparsity approach allows a balance between mathematical and ecological relevance. The original Stan codes can be found in his Github repository (https://github.com/tpweiss06/SparseInteractions under SparseInteractions/Empirical/StanCode/)
```{r run Preliminary fit}


# Set the parameters defining the regularized horseshoe prior, as described in
#       the "Incorporating sparsity-inducing priors" section of the manuscript.
tau0 <- 1
slab_scale <- sqrt(2)
slab_df <- 4
run_estimation <- 1


DataVec <- c("N", "S", 
             "Fecundity", "SpMatrix",
             "matrix_HOIs_plant",
             "Intra", "tau0", "slab_scale", "slab_df","run_estimation")

# Now run a perliminary fit of the model to assess parameter shrinkage
print("preliminary fit beginning")


PrelimFit <- stan(file = "code/Caracoles_BH_FH_Preliminary.stan", 
                  data=DataVec, 
                  init=0, # all initial values are 0 
                  iter = 1000, 
                  chains = 3) #In a Bayes model, one needs to run multiple chains to ensure the systematic convergence of the model towards a target distribution.


FileName <- paste("results/PrelimFit_", years,"_",complexity.plant,"_",FocalPrefix, ".rdata", sep = "")

save(PrelimFit, SpNames, N,S,Fecundity,year,complexity.plant,FocalPrefix, 
     SpMatrix,
     matrix_HOIs_plant,
     Intra,file = FileName)

PrelimPosteriors <- rstan::extract(PrelimFit)

print("preliminary fit done")
```
```{r load Prelim Fit, include=FALSE}
# load the .Rdata of the stan model when knitiing the project. No need to rerun the stan model
load("results/PrelimFit.rdata")
PrelimPosteriors <- rstan::extract(PrelimFit)
```

## Internal checks of the behaviour of the Bayes Model
Here, we see a  good mixing behavior as it explores the region with most of the density smoothly and bounces from one point to another quickly. Similarly, the density plots show a good repartition of the values explored around a mean. 

```{r Prelim Fit- behaviour plots, echo=FALSE}
source("stan_modelcheck_rem.R") # call the functions to check diagnistic plots

# plot the corresponding graphs
stan_model_check(PrelimFit,
                 params=c('lambdas','alpha_generic_tilde',
                          'beta_plant_generic_tilde','disp_dev'))


```
Here, we have the following interpretation of the numerical conditions and graphs, assessing Bayes's model behavior. 

+ Divergence -(numerical divergent transitions < 5). Zero divergences observe. Behavior is respected.
+ Tree depth: maximum number of steps to take in each iteration (here 10). Maximum number of steps was never reached. For a maximum Tree depth of 3 and 4, the violin plots show (i) a good distribution along the Log Posterior, (ii) a good distribtuion of the Mean Metrop. Acceptance, always above 40%. 
+ Rhat range - Both numerical(Rhat < 1.1) and graphic. The range of Rhat is concentrated around 1, and does not exceed the threshold of 1.1. 
+ N_eff range - Both numerical(Neff > 100) and graphic. The range of Neff is large and its lower boundary is superior to 100. The ratio between Effective sample size/ Sample size shows a great sampling behavior with a distribution rarely smaller than 1. 
+ Monte Carlo standard error - the ratio of Monte Carlo standard error. The ratio of Monte Carlo SE/Posterior SD, is small, yet could be smaller. The estimated posterior mean has a range variation still too important, the sampling behavior could reach a better approximation with a better model. 
+ Log Posterior (lp)
+ Metropolis acceptance (Mean Metrop. Acceptance) - The overall mean and median of the Metrop. Acceptance is between 80 to 95%, which shows good sampling behavior, toward the stationary distribution. Each chain has a similar Mean Metrop. Acceptance, distribution.

```{r Prelim Fit- Diagnostic plots, echo=FALSE}
source("stan_modelcheck_rem.R") # call the functions to check diagnistic plots
# plot the corresponding graphs
stan_diagnostic(TestFit_simplemodel)
```

## Extraction of relevant interactions
If the diagnostic plots don't reveal any problems with the model fit, we can move on to determining which interactions warrant inclusion in the final model (i.e. the data pulled their posteriors away from 0). The final model will then be run with only these species-specific parameters, but without the regularized horseshoe priors.

```{r Extraction interactions, echo=FALSE}
#### If the diagnostic plots don't reveal any problems wiht the model fit, now
#       move on to determining which parameters warrant inclusion in the final
#       model (i.e. the data pulled their posteriors away from 0). The final model
#       will then be run with only these species-specific parameters, but without
#       the regularized horseshoe priors.
Inclusion_ij <- matrix(data = 0, nrow = 1, ncol = length(SpNames),
                       dimnames=list(c(""),c(names(SpTotals[SpTotals!=SpToKeep]))))

beta_Inclusion_plant <- matrix(data = 0,nrow = length(SpNames), 
                               ncol = length(SpNames),
                               dimnames=list(c(names(SpTotals[SpTotals!=SpToKeep])),
                                             c(names(SpTotals[SpTotals!=SpToKeep]))))

IntLevel <- 0.9 #0.5 usually, 0.75 for Waitzia, shade
is.list(PrelimPosteriors$beta_hat_ij)
#str(PrelimPosteriors$beta_hat_ijk)
#str(PrelimPosteriors$alpha_hat_ij)
#For plants as second actor
for(s in 1:length(SpNames)){
  # hdi : Calculate the highest density interval (HDI) for a probability distribution for a given probability mass
  Ints_ij <- HDInterval::hdi(PrelimPosteriors$alpha_hat_ij[,s], credMass = IntLevel)
  if(Ints_ij[1] > 0 | Ints_ij[2] < 0){
    Inclusion_ij[1,s] <- 1
  }
  #for(m in 1:S){
  #  beta_Ints_ijk <- HDInterval::hdi(PrelimPosteriors$beta_plant_hat_ijk[,s,m], credMass = IntLevel)
    
   # if(beta_Ints_ijk[1] > 0 | beta_Ints_ijk[2] < 0){
   #   beta_Inclusion_plant[s,m] <- 1
   # }
  #}
}


write.csv(Inclusion_ij,
          paste0("results/Inclusion_ij_",years,"_",complexity.plant,
                 "_",complexity.animal,"_",FocalPrefix,".csv"))

#---- Final fit ---- 

DataVec <- c("N", "S","Intra",
             "Fecundity", "SpMatrix","matrix_HOIs_plant",
             "Inclusion_ij","beta_Inclusion_plant")

```

#Final fit 

We can run the final fit with the species-specific relevant interactions.

```{r run final fit, echo=FALSE}

run_estimation <- 1


DataVec <- c("N", "S","Fv",
             "Fecundity", "SpMatrix","HTLMatrix",
             "matrix_HOIs_plant",
             "Inclusion_ij","beta_Inclusion_plant",
             "Intra","run_estimation")

FinalFit <- stan(file = "Caracoles_BH_Final.stan", 
                  data = DataVec,
                  init=0, # all initial values are 0 
                  iter = 1000, 
                  control=list(max_treedepth=12),
                  chains = 3)



#FileName <- paste("/home/lisavm/Simulations/", FocalPrefix, "_", "_FinalFit.rdata", sep = "")
FileName <- paste("results/FinalFit_", years,"_",complexity.plant,"_",FocalPrefix, ".rdata", sep = "")

save(FinalFit, SpNames, N,S,Fecundity,year,complexity.plant,FocalPrefix, 
     SpMatrix,
     matrix_HOIs_plant,
     Intra,Inclusion_ij,beta_Inclusion_plant,
     tau0, slab_scale, slab_df,file = FileName)
print("Test fit for FinalFit")

```

```{r load final fit, include=FALSE}
# load the .Rdata of the stan model when knitiing the project. No need to rerun the stan model
load("results/FinalFit.rdata")
FinalFit_Posteriors <- rstan::extract(FinalFit)
```

## Internal checks of the behaviour of the Bayes Model
Here, we see a  good mixing behavior as it explores the region with most of the density smoothly and bounces from one point to another quickly. Similarly, the density plots show a good repartition of the values explored around a mean. 

```{r Final Fit- behaviour plots, echo=FALSE}
source("stan_modelcheck_rem.R") # call the functions to check diagnistic plots

# plot the corresponding graphs
stan_model_check(FinalFit,
                 params=c('lambdas','alpha_generic_tilde',
                          'beta_plant_generic_tilde','disp_dev'))


```
Here, we have the following interpretation of the numerical conditions and graphs, assessing Bayes's model behavior. 

+ Divergence -(numerical divergent transitions < 5). Zero divergences observe. Behavior is respected.
+ Tree depth: maximum number of steps to take in each iteration (here 10). Maximum number of steps was never reached. For a maximum Tree depth of 3 and 4, the violin plots show (i) a good distribution along the Log Posterior, (ii) a good distribtuion of the Mean Metrop. Acceptance, always above 40%. 
+ Rhat range - Both numerical(Rhat < 1.1) and graphic. The range of Rhat is concentrated around 1, and does not exceed the threshold of 1.1. 
+ N_eff range - Both numerical(Neff > 100) and graphic. The range of Neff is large and its lower boundary is superior to 100. The ratio between Effective sample size/ Sample size shows a great sampling behavior with a distribution rarely smaller than 1. 
+ Monte Carlo standard error - the ratio of Monte Carlo standard error. The ratio of Monte Carlo SE/Posterior SD, is small, yet could be smaller. The estimated posterior mean has a range variation still too important, the sampling behavior could reach a better approximation with a better model. 
+ Log Posterior (lp)
+ Metropolis acceptance (Mean Metrop. Acceptance) - The overall mean and median of the Metrop. Acceptance is between 80 to 95%, which shows good sampling behavior, toward the stationary distribution. Each chain has a similar Mean Metrop. Acceptance, distribution.

```{r Final Fit- Diagnostic plots, echo=FALSE}
source("stan_modelcheck_rem.R") # call the functions to check diagnistic plots
# plot the corresponding graphs
stan_diagnostic(FinalFit)
```

## Does the complex model produce relevant estimates ? 
### Test fecundity distribution

First, we can look at the distributions of the fecundity for our focal species through all observations between the Bayesian  estimation (blue), glm estimation (black), and the set value (orange). 

```{r Final Fit- fecundity, echo=FALSE}

FinalFitdistribution <- FinalFit %>% 
  as.data.frame() %>% 
  dplyr::select(contains("F_sim")) %>%
gather( key="obervation",value="seed")
#summary(Test_Fecunditydistribution)

Fecunditydistribution<- bind_rows(data.frame(estimated = "FinalFit Bayes model",seed = FinalFitdistribution$seed),
          data.frame(estimated = "Initial Fecundity", seed = Fecundity))


ggplot(Fecunditydistribution,
       aes(seed,y= ..scaled..,
           group=estimated,
           color=estimated)) +
  geom_density(kernel = "gaussian",stat = "density") +
  xlab(paste0("seeds of focal species ",focal)) +
   xlim(c(0,800)) +
  ggtitle(paste(" Distribution of fecundity for focal species",focal))  +
   scale_color_colorblind() +
  theme_bw()

```
### See pairwise interactions distribution

The distribution of the generic pairwise interactions estimated by the Bayes model (blue distribution). 

```{r Final Fit- parameters generic pairwise interactions, echo=FALSE}
# generic pairwise interactions 
GenericAlphadistribution <- data.frame(estimated = "Final Fit Bayes model", alpha =FinalFit_Posterior$alpha_generic)

ggplot(GenericAlphadistribution,aes(x=alpha,y = ..scaled..,color=estimated)) +
  geom_density(kernel = "gaussian") +
  xlab("distribution of  \n coefficient") +
  scale_color_manual(values=c("#56B4E9")) +
  ggtitle(paste(" Distribution of generic pairwise interactions for focal species",focal)) +theme_bw()

``` 

The distribution of the specific pairwise interaction estimated by the Bayesmodel (blue distribution).  

```{r Final Fit - parameters specific pairwise interaction, echo=FALSE}
Alphasdistribution <- as.data.frame(FinalFit_Posterior$alpha_hat_ij  + median(FinalFit_Posterior$alpha_generic))
# specific pairwise interaction
 List_Alphasdistribution <- list()
 for (i in 1:S){
   #message(i)
   List_Alphasdistribution[[i]] <- local({
     i <- i
     p1 <-  ggplot(Alphasdistribution,
                   aes(get(paste0("V",i)))) +
       geom_density(kernel = "gaussian",color="#56B4E9") +
       xlab("distribution of  \n coefficient (exp)") +
       ggtitle(paste("Species",i)) +theme_bw()
     
     #print(p1)
   })
 }
 plot_alpha_specific <- ggarrange(plotlist=List_Alphasdistribution) 
   annotate_figure( plot_alpha_specific, top = text_grob("Distribution of specific \n pairwise interaction for neighbour:", 
               color = "black", face = "bold", size = 14))
   
``` 

### HOIs distribution

The distribution of the generic HOIs for neighbour estimated by the Bayesmodel (blue distribution). 

```{r Final Fit - parameters generic HOIs, echo=FALSE}

# generic HOIs for neighbour

GenericBetadistribution <- as.data.frame(FinalFit_Posterior$beta_plant_generic)
 List_GenericBetadistribution <- list()
 for (i in 1:S){
   #message(i)
   List_GenericBetadistribution[[i]] <- local({
     i <- i
    GenericBetadistribution_i <-bind_rows(data.frame(estimated = "Complex Bayes model", beta =GenericBetadistribution[,paste0("V",i)]))
    
  
     p1 <-  ggplot(GenericBetadistribution_i,aes(x=beta,y = ..scaled..,color=estimated)) +
  geom_density(kernel = "gaussian",stat = "density") +
  xlab("distribution of  \n coefficient") +
  scale_color_manual(values=c("#56B4E9"))+
       ggtitle(paste("Species",i)) +
       xlim(c(-1,5)) +theme_bw()
     
     #print(p1)
   })
 }
 
 plot_HOIs_generic <- ggarrange(plotlist=List_GenericBetadistribution,common.legend =T)
 annotate_figure(plot_HOIs_generic, top = text_grob("Distribution of generic HOIs for neighbour:", 
               color = "black", face = "bold", size = 14))
 
``` 

The distribution of the specific HOI for neighbour species estimated by the Bayesmodel (blue distribution).   

```{r test complex model- parameters specific HOI, echo=FALSE} 
# specific HOI for neighbour species
 Betasdistribution <- list(FinalFit_Posterior$beta_plant_hat_ijk)

 for (i in 1:S){
   #message(i)
   List_Betasdistribution <- list()
   Betasdistribution_sp <- as.data.frame(FinalFit_Posterior$beta_plant_hat_ijk[,,i] +
                                                median(FinalFit_Posterior$beta_plant_generic[,i]))
   
   for(j in 1:S){
    # message(j)
   List_Betasdistribution[[j]] <- local({
     i <- i
     j <- j
     p1 <-  ggplot(Betasdistribution_sp,
                   aes(get(paste0("V",j)))) +
       xlim(c(-1,5)) + 
       geom_density(kernel = "gaussian",color="#56B4E9") +
       xlab("distribution of  \n coefficient (exp)") +
       ggtitle(paste("Species",i," and ",j)) +        theme_bw()
     
     #print(p1)
   })
   }
   plot_HOIs_specific <-ggarrange(plotlist=List_Betasdistribution)
   local(print(
                annotate_figure(plot_HOIs_specific, top = text_grob("Distribution of specific HOI for neighbour:", 
               color = "black", face = "bold", size = 14))))
 }
```

